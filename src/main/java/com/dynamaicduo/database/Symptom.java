package com.dynamicduo.database;

import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;
import com.amazonaws.services.dynamodbv2.datamodeling.*;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig.TableNameOverride;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBRangeKey;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBQueryExpression;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBScanExpression;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
// import com.amazonaws.services.dynamodbv2.datamodeling.PaginatedQueryList;
// import com.amazonaws.services.dynamodbv2.datamodeling.PaginatedQueryList;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIndexHashKey;
// import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIndexRangeKey;

import com.amazonaws.services.dynamodbv2.model.AttributeValue;

import java.io.IOException;
// import java.text.Attribute;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.Date;
import java.time.Instant;
import java.util.Arrays;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jdk.jfr.Frequency;
import sun.font.AttributeValues;

@DynamoDBTable(tableName = "PLACEHOLDER")
public class Symptom {

    private static final String PATIENT_TABLE_NAME = System.getenv("PATIENT_TABLE");

    private static DynamoDBAdapter db_adapter;
    private final AmazonDynamoDB client;
    private final DynamoDBMapper mapper;

    private final Logger LOG = LogManager.getLogger(this.getClass());

    private String userId;
    private String recordTime;
    private String symptomId;
    private String symptomName;
    private String startDate;
    private String symptomLocation;
    private String symptomLocationDescription;
    private String symptomMovement;
    private String frequency;
    private String symptomConsistency;
    private String severity;
    private String symptomDescription;
    private String previousItemId;
    private String completionTime;
    private String reviewTime;
    private String resolvedDate;
    private String betterCondition;
    private String worseCondition;
    private String impactToLife;
    private String otherRelatedSymptom;

    @DynamoDBHashKey(attributeName="userId")
    @DynamoDBIndexHashKey(globalSecondaryIndexName = "userId-reviewTime-index", attributeName = "userId")
    public String getUserId() { return this.userId; }
    public void setUserId(String userId) { this.userId = userId; }

    @DynamoDBRangeKey(attributeName = "recordTime")
    public String getRecordTime() { return this.recordTime; }
    public void setRecordTime(String recordTime) { this.recordTime = recordTime; }

    @DynamoDBIndexRangeKey(globalSecondaryIndexName = "userId-reviewTime-index", attributeName = "reviewTime")
    public String getReviewTime() { return this.reviewTime; }
    public void setReviewTime(String reviewTime) { this.reviewTime = reviewTime; }

    @DynamoDBAttribute(attributeName = "symptomId")
    public String getSymptomId() { return this.symptomId; }
    public void setSymptomId(String symptomId) { this.symptomId = symptomId; }

    @DynamoDBAttribute(attributeName = "symptomName")
    public String getSymptomName() { return this.symptomName; }
    public void setSymptomName(String symptomName) { this.symptomName = symptomName; }

    @DynamoDBAttribute(attributeName = "startDate")
    public String getStartDate() { return this.startDate; }
    public void setStartDate(String startDate) { this.startDate = startDate; }

    @DynamoDBAttribute(attributeName = "symptomLocation")
    public String getSymptomLocation() { return this.symptomLocation; }
    public void setSymptomLocation(String symptomLocation) { this.symptomLocation = symptomLocation; }

    @DynamoDBAttribute(attributeName = "symptomLocationDescription")
    public String getSymptomLocationDescription() { return this.symptomLocationDescription; }
    public void setSymptomLocationDescription(String symptomLocationDescription) { this.symptomLocationDescription = symptomLocationDescription; }

    @DynamoDBAttribute(attributeName = "symptomMovement")
    public String getSymptomMovement() { return this.symptomMovement; }
    public void setSymptomMovement(String symptomMovement) { this.symptomMovement = symptomMovement; }
    
    @DynamoDBAttribute(attributeName = "frequency")
    public String getFrequency() { return this.frequency; }
    public void setFrequency(String frequency) { this.frequency = frequency; }

    @DynamoDBAttribute(attributeName = "symptomConsistency")
    public String getSymptomConsistency() { return this.symptomConsistency; }
    public void setSymptomConsistency(String symptomConsistency) { this.symptomConsistency = symptomConsistency; }
    
    @DynamoDBAttribute(attributeName = "severity")
    public String getSeverity() { return this.severity; }
    public void setSeverity(String severity) { this.severity = severity; }
    
    @DynamoDBAttribute(attributeName = "symptomDescription")
    public String getSymptomDescription() { return this.symptomDescription; }
    public void setSymptomDescription(String symptomDescription) { this.symptomDescription = symptomDescription; }

    @DynamoDBAttribute(attributeName = "previousItemId")
    public String getPreviousItemId() { return this.previousItemId; }
    public void setPreviousItemId(String previousItemId) { this.previousItemId = previousItemId; }

    @DynamoDBAttribute(attributeName = "completionTime")
    public String getCompletionTime() { return this.completionTime; }
    public void setCompletionTime(String completionTime) { this.completionTime = completionTime; }
    
    @DynamoDBAttribute(attributeName = "resolvedDate")
    public String getResolvedDate() { return this.resolvedDate; }
    public void setResolvedDate(String resolvedDate) { this.resolvedDate = resolvedDate; }

    @DynamoDBAttribute(attributeName = "betterCondition")
    public String getBetterCondition() { return this.betterCondition; }
    public void setBetterCondition(String betterCondition) { this.betterCondition = betterCondition; }

    @DynamoDBAttribute(attributeName = "worseCondition")
    public String getWorseCondition() { return this.worseCondition; }
    public void setWorseCondition(String worseCondition) { this.worseCondition = worseCondition; }

    @DynamoDBAttribute(attributeName = "impactToLife")
    public String getImpactToLife() { return this.impactToLife; }
    public void setImpactToLife(String impactToLife) { this.impactToLife = impactToLife; }

    @DynamoDBAttribute(attributeName = "otherRelatedSymptom")
    public String getOtherRelatedSymptom() { return this.otherRelatedSymptom; }
    public void setOtherRelatedSymptom(String otherRelatedSymptom) { this.otherRelatedSymptom = otherRelatedSymptom; }



    public Symptom() {
        DynamoDBMapperConfig mapperConfig = DynamoDBMapperConfig.builder()
            .withTableNameOverride(new DynamoDBMapperConfig.TableNameOverride(PATIENT_TABLE_NAME))
            .build();
        this.db_adapter = DynamoDBAdapter.getInstance();
        this.client = this.db_adapter.getDbClient();
        this.mapper = this.db_adapter.createDbMapper(mapperConfig);
    }

    public String toString() {
        return String.format("Symptom [id=%s]", this.userId);
    }

    public Symptom save() throws IOException {
        this.mapper.save(this);
        return get(this.userId, this.recordTime);
    }
    public Symptom get(String userId, String recordTime) throws IOException {
        return this.mapper.load(Symptom.class, userId, recordTime);
    }
    public boolean delete(String userId, String recordTime) throws IOException {
        Symptom symptom = get(userId, recordTime);
        this.mapper.delete(symptom);

        return true;
    }
    // public boolean completeSymptom(String userId, String recordTime, HashMap<String, AttributeValue> params) throws IOException{
    //     Symptom symptom = getOneSymptom(userId, recordTime);
    //     //TODO
    //     return true;

    // }
    
    public Symptom update() throws IOException{
        return save();
    }
    public Symptom getOneSymptom(String userId, String recordTime) throws IOException{
        return this.mapper.load(Symptom.class, userId, recordTime);
    }
    public Symptom[] getSymptoms(String userId, String lastDays, String resolvedState, String sortBy) throws IOException{
        Long curDayEpoch = new Date().getTime();
        Long startDayEpoch = lastDays.equals("") ? 1L : curDayEpoch - 86400 * Integer.parseInt(lastDays);
        String filterExpression = (resolvedState.equals("")  || resolvedState.equals("true") ) ?  "resolvedDate > :rD" : "resolvedDate = :rD"; 
        HashMap<String, AttributeValue> attributes = new HashMap<String, AttributeValue>();
        attributes.put(":uId", new AttributeValue().withS(userId));
        attributes.put(":rT", new AttributeValue().withS("SYMPTOM#" + startDayEpoch.toString()));
        attributes.put(":rD", new AttributeValue().withS(resolvedState.equals("") ? "-1" : "0"));
        DynamoDBQueryExpression<Symptom> queryExpression = new DynamoDBQueryExpression<Symptom>()
        .withKeyConditionExpression("userId = :uId and recordTime > :rT")
        .withFilterExpression(filterExpression).
        withExpressionAttributeValues(attributes);

        PaginatedQueryList<Symptom> symptoms = this.mapper.query(Symptom.class, queryExpression);
        Symptom[] returnedSymptoms = symptoms.toArray(new Symptom[symptoms.size()]);
        if (returnedSymptoms.length > 0 && !sortBy.equals("")) {
            switch(sortBy){
                case "severity":
                    // sort by severtity increasing order first, if same, by record time (reverse order)
                    Arrays.sort(returnedSymptoms, (s1,s2) -> s1.getSeverity().equals(s2.getSeverity()) ? s2.getRecordTime().compareTo(s1.getRecordTime()) : s1.getSeverity().compareTo(s2.getSeverity()));
                    break;
                case "startDate":
                Arrays.sort(returnedSymptoms, (s1,s2) -> s1.getStartDate().equals(s2.getStartDate()) ? s2.getRecordTime().compareTo(s1.getRecordTime()) : s1.getStartDate().compareTo(s2.getStartDate()));
                    break;
                case "symptomName":
                    Arrays.sort(returnedSymptoms, (s1,s2) -> s1.getSymptomName().equals(s2.getSymptomName()) ? s2.getRecordTime().compareTo(s1.getRecordTime()) : s1.getSymptomName().compareTo(s2.getSymptomName()));
                    break;
                default:
                    break;
            }
        }
        return returnedSymptoms;
    }

    public Symptom[] getSymptomsByCompletionRange(String userId, String startTime, String endTime) {
        // startTime and endTime are both mandatory
        
        HashMap<String, AttributeValue> attributes = new HashMap<String, AttributeValue>();
        attributes.put(":uId", new AttributeValue().withS(userId));
        attributes.put(":sT", new AttributeValue().withS("SYMPTOM#" + startTime));
        attributes.put(":eT", new AttributeValue().withS("SYMPTOM#" + endTime));
        attributes.put(":cT", new AttributeValue().withS("0"));
        DynamoDBQueryExpression<Symptom> queryExpression = new DynamoDBQueryExpression<Symptom>()
        .withKeyConditionExpression("userId = :uId and recordTime between :sT and :eT")
        .withFilterExpression("completionTime > :cT").
        withExpressionAttributeValues(attributes);
    
        PaginatedQueryList<Symptom> symptoms = this.mapper.query(Symptom.class, queryExpression);
        Symptom[] returnedSymptoms = symptoms.toArray(new Symptom[symptoms.size()]);
        return returnedSymptoms;
    }

    public Symptom[] getReviewSymptoms(String userId, String startTime, String endTime) {
        // startTime and endTime are both mandatory
        
        HashMap<String, AttributeValue> attributes = new HashMap<String, AttributeValue>();
        attributes.put(":uId", new AttributeValue().withS(userId));
        attributes.put(":sT", new AttributeValue().withS("SYMPTOM#" + startTime));
        attributes.put(":eT", new AttributeValue().withS("SYMPTOM#" + endTime));
        DynamoDBQueryExpression<Symptom> queryExpression = new DynamoDBQueryExpression<Symptom>()
        .withConsistentRead(false)
        .withIndexName("userId-reviewTime-index")
        .withKeyConditionExpression("userId = :uId and reviewTime between :sT and :eT")
        .withExpressionAttributeValues(attributes);
    
        PaginatedQueryList<Symptom> symptoms = this.mapper.query(Symptom.class, queryExpression);
        Symptom[] returnedSymptoms = symptoms.toArray(new Symptom[symptoms.size()]);
        return returnedSymptoms;
    }
}
